<!doctype html>
<html lang="en">
<head>
<meta charset="utf-8">
<meta name="viewport" content="width=device-width, initial-scale=1, minimum-scale=1" />
<meta name="generator" content="pdoc 0.10.0" />
<title>Maze API documentation</title>
<meta name="description" content="" />
<link rel="preload stylesheet" as="style" href="https://cdnjs.cloudflare.com/ajax/libs/10up-sanitize.css/11.0.1/sanitize.min.css" integrity="sha256-PK9q560IAAa6WVRRh76LtCaI8pjTJ2z11v0miyNNjrs=" crossorigin>
<link rel="preload stylesheet" as="style" href="https://cdnjs.cloudflare.com/ajax/libs/10up-sanitize.css/11.0.1/typography.min.css" integrity="sha256-7l/o7C8jubJiy74VsKTidCy1yBkRtiUGbVkYBylBqUg=" crossorigin>
<link rel="stylesheet preload" as="style" href="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/10.1.1/styles/github.min.css" crossorigin>
<style>:root{--highlight-color:#fe9}.flex{display:flex !important}body{line-height:1.5em}#content{padding:20px}#sidebar{padding:30px;overflow:hidden}#sidebar > *:last-child{margin-bottom:2cm}.http-server-breadcrumbs{font-size:130%;margin:0 0 15px 0}#footer{font-size:.75em;padding:5px 30px;border-top:1px solid #ddd;text-align:right}#footer p{margin:0 0 0 1em;display:inline-block}#footer p:last-child{margin-right:30px}h1,h2,h3,h4,h5{font-weight:300}h1{font-size:2.5em;line-height:1.1em}h2{font-size:1.75em;margin:1em 0 .50em 0}h3{font-size:1.4em;margin:25px 0 10px 0}h4{margin:0;font-size:105%}h1:target,h2:target,h3:target,h4:target,h5:target,h6:target{background:var(--highlight-color);padding:.2em 0}a{color:#058;text-decoration:none;transition:color .3s ease-in-out}a:hover{color:#e82}.title code{font-weight:bold}h2[id^="header-"]{margin-top:2em}.ident{color:#900}pre code{background:#f8f8f8;font-size:.8em;line-height:1.4em}code{background:#f2f2f1;padding:1px 4px;overflow-wrap:break-word}h1 code{background:transparent}pre{background:#f8f8f8;border:0;border-top:1px solid #ccc;border-bottom:1px solid #ccc;margin:1em 0;padding:1ex}#http-server-module-list{display:flex;flex-flow:column}#http-server-module-list div{display:flex}#http-server-module-list dt{min-width:10%}#http-server-module-list p{margin-top:0}.toc ul,#index{list-style-type:none;margin:0;padding:0}#index code{background:transparent}#index h3{border-bottom:1px solid #ddd}#index ul{padding:0}#index h4{margin-top:.6em;font-weight:bold}@media (min-width:200ex){#index .two-column{column-count:2}}@media (min-width:300ex){#index .two-column{column-count:3}}dl{margin-bottom:2em}dl dl:last-child{margin-bottom:4em}dd{margin:0 0 1em 3em}#header-classes + dl > dd{margin-bottom:3em}dd dd{margin-left:2em}dd p{margin:10px 0}.name{background:#eee;font-weight:bold;font-size:.85em;padding:5px 10px;display:inline-block;min-width:40%}.name:hover{background:#e0e0e0}dt:target .name{background:var(--highlight-color)}.name > span:first-child{white-space:nowrap}.name.class > span:nth-child(2){margin-left:.4em}.inherited{color:#999;border-left:5px solid #eee;padding-left:1em}.inheritance em{font-style:normal;font-weight:bold}.desc h2{font-weight:400;font-size:1.25em}.desc h3{font-size:1em}.desc dt code{background:inherit}.source summary,.git-link-div{color:#666;text-align:right;font-weight:400;font-size:.8em;text-transform:uppercase}.source summary > *{white-space:nowrap;cursor:pointer}.git-link{color:inherit;margin-left:1em}.source pre{max-height:500px;overflow:auto;margin:0}.source pre code{font-size:12px;overflow:visible}.hlist{list-style:none}.hlist li{display:inline}.hlist li:after{content:',\2002'}.hlist li:last-child:after{content:none}.hlist .hlist{display:inline;padding-left:1em}img{max-width:100%}td{padding:0 .5em}.admonition{padding:.1em .5em;margin-bottom:1em}.admonition-title{font-weight:bold}.admonition.note,.admonition.info,.admonition.important{background:#aef}.admonition.todo,.admonition.versionadded,.admonition.tip,.admonition.hint{background:#dfd}.admonition.warning,.admonition.versionchanged,.admonition.deprecated{background:#fd4}.admonition.error,.admonition.danger,.admonition.caution{background:lightpink}</style>
<style media="screen and (min-width: 700px)">@media screen and (min-width:700px){#sidebar{width:30%;height:100vh;overflow:auto;position:sticky;top:0}#content{width:70%;max-width:100ch;padding:3em 4em;border-left:1px solid #ddd}pre code{font-size:1em}.item .name{font-size:1em}main{display:flex;flex-direction:row-reverse;justify-content:flex-end}.toc ul ul,#index ul{padding-left:1.5em}.toc > ul > li{margin-top:.5em}}</style>
<style media="print">@media print{#sidebar h1{page-break-before:always}.source{display:none}}@media print{*{background:transparent !important;color:#000 !important;box-shadow:none !important;text-shadow:none !important}a[href]:after{content:" (" attr(href) ")";font-size:90%}a[href][title]:after{content:none}abbr[title]:after{content:" (" attr(title) ")"}.ir a:after,a[href^="javascript:"]:after,a[href^="#"]:after{content:""}pre,blockquote{border:1px solid #999;page-break-inside:avoid}thead{display:table-header-group}tr,img{page-break-inside:avoid}img{max-width:100% !important}@page{margin:0.5cm}p,h2,h3{orphans:3;widows:3}h1,h2,h3,h4,h5,h6{page-break-after:avoid}}</style>
<script defer src="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/10.1.1/highlight.min.js" integrity="sha256-Uv3H6lx7dJmRfRvH8TH6kJD1TSK1aFcwgx+mdg3epi8=" crossorigin></script>
<script>window.addEventListener('DOMContentLoaded', () => hljs.initHighlighting())</script>
</head>
<body>
<main>
<article id="content">
<header>
<h1 class="title">Module <code>Maze</code></h1>
</header>
<section id="section-intro">
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">from random import *
import random

class Maze:
    &#34;&#34;&#34;
    Classe `Maze` (Labyrinthe) :
    Représentation d&#39;un labyrithe sous forme d&#39;un graphe non-orienté
    dont chaque sommet est une cellule (sous forme d&#39;un tuple (l,c))
    et dont la structure est représentée par un dictionnaire :
    clefs = sommets, valeurs = ensemble des sommets voisins accessibles.
    &#34;&#34;&#34;

    def __init__(self, height: int, width: int, empty: bool):
        &#34;&#34;&#34;
        Le constructeur de cette classe créer un labyrinthe de `height` cellules de haut
        et de `width` cellules de large.
        Les voisinages sont initialisés par des ensembles vides.
        Remarque : dans le labyrinthe créé, chaque cellule est complètement emmurée.
        Paramètres:
            `height` (int)

            `width` (int)

            `empty` (bool).
        &#34;&#34;&#34;
        self.height = height
        self.width = width

        # Si empty vaut True alors le constructeur initialise l&#39;objet sans murs internes sinon il construit tous les murs

        if empty:
            self.neighbors = {
                (i, j): set() for i in range(height) for j in range(width)
            }
            for h in range(height):
                for w in range(width):
                    if h - 1 &gt;= 0:
                        self.neighbors[(h, w)].add((h - 1, w))
                    if h + 1 &lt;= height - 1:
                        self.neighbors[(h, w)].add((h + 1, w))
                    if w - 1 &gt;= 0:
                        self.neighbors[(h, w)].add((h, w - 1))
                    if w + 1 &lt;= width - 1:
                        self.neighbors[(h, w)].add((h, w + 1))
        else:
            self.neighbors = {
                (i, j): set() for i in range(height) for j in range(width)
            }

    def info(self) -&gt; str:
        &#34;&#34;&#34;
        Affichage des attributs d&#39;un objet `Maze` (fonction utile pour deboguer).
        Retour:
            Chaîne de caractères (str) contenant une description textuelle des attributs de l&#39;intance.
        &#34;&#34;&#34;
        txt = f&#39;{self.height} x {self.width}\n&#39;
        txt += str(self.neighbors)
        return txt

    def __str__(self) -&gt; str:
        &#34;&#34;&#34;
        Représentation textuelle d&#39;une intance de l&#39;objet `Maze` (en utilisant des caractères ASCII).
        Retour:
             Chaîne de caractères (str) : chaîne de caractères représentant le labyrinthe
        :return:
        &#34;&#34;&#34;
        txt = &#39;&#39;
        # Première ligne
        txt += &#39;┏&#39;
        for j in range(self.width - 1):
            txt += &#39;━━━┳&#39;
        txt += &#39;━━━┓\n&#39;
        txt += &#39;┃&#39;
        for j in range(self.width - 1):
            txt += (
                &#39;   ┃&#39; if (0, j + 1) not in self.neighbors[(0, j)] else &#39;    &#39;
            )
        txt += &#39;   ┃\n&#39;
        # Lignes normales
        for i in range(self.height - 1):
            txt += &#39;┣&#39;
            for j in range(self.width - 1):
                txt += (
                    &#39;━━━╋&#39;
                    if (i + 1, j) not in self.neighbors[(i, j)]
                    else &#39;   ╋&#39;
                )
            txt += (
                &#39;━━━┫\n&#39;
                if (i + 1, self.width - 1)
                not in self.neighbors[(i, self.width - 1)]
                else &#39;   ┫\n&#39;
            )
            txt += &#39;┃&#39;
            for j in range(self.width):
                txt += (
                    &#39;   ┃&#39;
                    if (i + 1, j + 1) not in self.neighbors[(i + 1, j)]
                    else &#39;    &#39;
                )
            txt += &#39;\n&#39;
        # Bas du tableau
        txt += &#39;┗&#39;
        for i in range(self.width - 1):
            txt += &#39;━━━┻&#39;
        txt += &#39;━━━┛\n&#39;

        return txt

    def add_wall(self, c1, c2) -&gt; None:
        &#34;&#34;&#34;
        Méthode d&#39;instance permettant d&#39;ajouter un mur entre les deux cases passées en paramètres si et seulement si les coordonnées sont
        cohérentes.

        Paramètres:
            `c1` (tuple) : première coordonnée rerpésentant une case.

            `c2` (tuple) : deuxième coordonnée rerpésentant une autre case.
        &#34;&#34;&#34;
        # On teste si les sommets sont bien dans le labyrinthe
        assert (
            0 &lt;= c1[0] &lt; self.height
            and 0 &lt;= c1[1] &lt; self.width
            and 0 &lt;= c2[0] &lt; self.height
            and 0 &lt;= c2[1] &lt; self.width
        ), (
            &#34;Erreur lors de l&#39;ajout d&#39;un mur entre {c1} et {c2} : les coordonnées de sont pas compatibles avec les &#34;
            &#39;dimensions du labyrinthe&#39;
        )
        # Ajout du mur
        if c2 in self.neighbors[c1]:  # Si c2 est dans les voisines de c1
            self.neighbors[c1].remove(c2)  # on le retire
        if c1 in self.neighbors[c2]:  # Si c3 est dans les voisines de c2
            self.neighbors[c2].remove(c1)  # on le retire

        return None

    def remove_wall(self, c1, c2) -&gt; None:
        &#34;&#34;&#34;
        Méthode d&#39;instance permettant de supprimer un mur entre les deux cases passées en paramètres si et seulement si les coordonnées sont
        cohérentes.
        Paramètres:
            `c1` (tuple) : première coordonnée rerpésentant une case.

            `c2` (tuple) : deuxième coordonnée rerpésentant une autre case.
        &#34;&#34;&#34;
        # On teste si les sommets sont bien dans le labyrinthe
        assert (
            0 &lt;= c1[0] &lt; self.height
            and 0 &lt;= c1[1] &lt; self.width
            and 0 &lt;= c2[0] &lt; self.height
            and 0 &lt;= c2[1] &lt; self.width
        ), (
            &#34;Erreur lors de la suppression d&#39;un mur entre {c1} et {c2} : les coordonnées de sont pas compatibles avec &#34;
            &#39;les dimensions du labyrinthe&#39;
        )
        # Suppression du mur
        if (
            c2 not in self.neighbors[c1]
        ):  # Si c2 n&#39;est pas dans les voisines de c1
            self.neighbors[c1].add(c2)  # on l&#39;ajoute&#39;
        if (
            c1 not in self.neighbors[c2]
        ):  # Si c3 n&#39;est pas dans les voisines de c2
            self.neighbors[c2].add(c1)  # on l&#39;ajoute
        return None

    def get_walls(self) -&gt; list:
        &#34;&#34;&#34;
        Méthode d&#39;instance qui retourne la liste de tous les murs sous la forme d’une liste de tuple de cellules (
        sans redondance ou symétrie).
        &#34;&#34;&#34;
        list_wall = []
        for h in range(self.height):
            for w in range(self.width):

                if (
                    h - 1 &gt;= 0
                    and (h, w) not in self.neighbors[(h - 1, w)]
                    and (
                        ((h, w), (h - 1, w)) not in list_wall
                        and (
                            (h - 1, w),
                            (h, w),
                        )
                        not in list_wall
                    )
                ):
                    list_wall.append(((h, w), (h - 1, w)))

                if (
                    h + 1 &lt;= self.height - 1
                    and (h, w) not in self.neighbors[(h + 1, w)]
                    and (
                        ((h, w), (h + 1, w))
                        and ((h + 1, w), (h, w)) not in list_wall
                    )
                ):
                    list_wall.append(((h, w), (h + 1, w)))

                if (
                    w - 1 &gt;= 0
                    and (h, w) not in self.neighbors[(h, w - 1)]
                    and (
                        ((h, w), (h, w - 1)) not in list_wall
                        and ((h, w - 1), (h, w)) not in list_wall
                    )
                ):
                    list_wall.append(((h, w), (h, w - 1)))

                if (
                    w + 1 &lt;= self.width - 1
                    and (h, w) not in self.neighbors[(h, w + 1)]
                    and (
                        ((h, w), (h, w + 1)) not in list_wall
                        and ((h, w + 1), (h, w)) not in list_wall
                    )
                ):
                    list_wall.append(((h, w), (h, w + 1)))

        return list_wall

    def fill(self) -&gt; None:
        &#34;&#34;&#34;
        Méthode d&#39;instance qui ajoute tous les murs possibles dans un labyrinthe.
        &#34;&#34;&#34;
        for h in range(self.height):
            for w in range(self.width):
                for voisin in self.neighbors[(h, w)].copy():
                    self.add_wall((h, w), voisin)
        return None

    def empty(self) -&gt; None:
        &#34;&#34;&#34;
        Méthode d&#39;instance qui supprime tous les murs d&#39;un labyrinthe.
        &#34;&#34;&#34;
        list_wall = self.get_walls()
        for wall in list_wall:
            self.remove_wall(wall[0], wall[1])
        return None

    def get_contiguous_cells(self, c: tuple) -&gt; list:
        &#34;&#34;&#34;
        Méthode d&#39;instance qui retourne la liste des cellules contigües à une cellule `c` (tuple) passée en paramètre dans la grille (sans s’occuper des
        éventuels murs).

        Paramètre:
            `c` (tuple) : coordonnées d&#39;une cellule.

        Retour:
            Liste de toutes les cellules contigües à `c`.
        &#34;&#34;&#34;
        list_contigue = []
        if c[0] - 1 &gt;= 0:
            list_contigue.append((c[0] - 1, c[1]))
        if c[0] + 1 &lt;= self.height - 1:
            list_contigue.append((c[0] + 1, c[1]))
        if c[1] - 1 &gt;= 0:
            list_contigue.append((c[0], c[1] - 1))
        if c[1] + 1 &lt;= self.width - 1:
            list_contigue.append((c[0], c[1] + 1))

        return list_contigue

    def get_reachable_cells(self, c: tuple) -&gt; list:
        return list(self.neighbors[c].copy())

    def gen_btree(self, h: int, w: int) -&gt; object:
        &#34;&#34;&#34;
        Méthode d&#39;instance qui génère un labyrinthe qui possède `h` lignes et `w`` colonnes en utilisant l’algorithme de
        construction par arbre binaire.

        Paramètres:
            `h` (int) : nombre de cases en hauteur du labyrinthe voulu.
            `w` (int) : nombre de cases en largeur du labyrinthe voulu.

        Retour:
            Retourne une instance de `Maze`.
        &#34;&#34;&#34;
        new_maze = Maze(h, w, False)
        for h in range(new_maze.height):
            for w in range(new_maze.width):

                temp_wall = new_maze.get_walls()
                if (
                    random.choice([True, False])
                    and w + 1 &lt;= new_maze.width - 1
                ):
                    if ((h, w), (h, w + 1)) in temp_wall:
                        new_maze.remove_wall((h, w), (h, w + 1))
                    elif h + 1 &lt;= new_maze.height - 1:
                        new_maze.remove_wall((h, w), (h + 1, w))

                else:
                    if (
                        (h, w),
                        (h + 1, w),
                    ) in temp_wall and h + 1 &lt;= new_maze.height - 1:
                        new_maze.remove_wall((h, w), (h + 1, w))
                    elif w + 1 &lt;= new_maze.width - 1:
                        new_maze.remove_wall((h, w), (h, w + 1))

        return new_maze

    def gen_sidewinder(self, h: int, w: int) -&gt; object:
        &#34;&#34;&#34;
        Méthode d&#39;instance qui génère un labyrinthe de `h` lignes et `w` colonnes en utilisant l’algorithme de construction
        Sidewinder.

        Paramètres:
            `h` (int) : nombre de cases en hauteur du labyrinthe voulu.
            `w` (int) : nombre de cases en largeur du labyrinthe voulu.

        Retour:
            Retourne une instance de `Maze`.
        &#34;&#34;&#34;
        new_maze = Maze(h, w, False)

        for h in range(new_maze.height - 1):
            v_seq = []
            for w in range(new_maze.width - 1):
                v_seq.append((h, w))
                if random.choice([True, False]):
                    new_maze.remove_wall((h, w), (h, w + 1))
                else:
                    choix = random.choice(v_seq)
                    new_maze.remove_wall(choix, (choix[0] + 1, choix[1]))
                    v_seq.clear()
            v_seq.append((h, new_maze.width - 1))
            choix = random.choice(v_seq)
            new_maze.remove_wall(choix, (choix[0] + 1, choix[1]))

        for w in range(new_maze.width - 1):
            new_maze.remove_wall(
                (new_maze.height - 1, w), (new_maze.height - 1, w + 1)
            )
        return new_maze

    def gen_fusion(self, h, w) -&gt; object:
        &#34;&#34;&#34;
        Méthode d&#39;instance qui génère un labyrinthe de `h` lignes et `w` colonnes parfait à l&#39;aide de l’algorithme de fusion de chemins.

        Paramètres:
            `h` (int) : nombre de cases en hauteur du labyrinthe voulu.
            `w` (int) : nombre de cases en largeur du labyrinthe voulu.

        Retour:
            Retourne une instance de `Maze`.
        &#34;&#34;&#34;
        new_maze = Maze(h, w, False)
        label = {(i, j): None for i in range(h) for j in range(w)}
        idx = 1
        for h in range(new_maze.height):
            for w in range(new_maze.width):
                # Ajout des label aux cellules
                label[(h, w)] = idx
                idx += 1
        list_wall = new_maze.get_walls()
        random.shuffle(list_wall)

        for wall in list_wall:
            if label[wall[0]] != label[wall[1]]:
                temp = label[wall[1]]
                for idx in label:
                    if label[idx] == temp:
                        label[idx] = label[wall[0]]
                new_maze.remove_wall(wall[0], wall[1])
        return new_maze

    def gen_exploration(self, h, w) -&gt; object:
        &#34;&#34;&#34;
        Methode d&#39;instance qui génère un labyrinthe à `h` lignes et `w` colonnes parfait à l&#39;aide de l’algorithme d’exploration exhaustive.

        Paramètres:
            `h` (int) : nombre de cases en hauteur du labyrinthe voulu.
            `w` (int) : nombre de cases en largeur du labyrinthe voulu.

        Retour:
            Retourne une instance de `Maze`.
        &#34;&#34;&#34;
        new_maze = Maze(h, w, False)
        flag = {(i, j): False for i in range(h) for j in range(w)}
        pile = []
        temp = (random.randint(0, h - 1), random.randint(0, w - 1))
        pile.append(temp)
        flag[temp] = True
        while pile:
            temp = pile[len(pile) - 1]
            pile.pop(len(pile) - 1)
            temp_test = False
            temp_contiguous = new_maze.get_contiguous_cells(temp)
            for neighbors in temp_contiguous.copy():
                if not flag[neighbors]:
                    temp_test = True
                else:
                    temp_contiguous.remove(neighbors)
            if temp_test:
                pile.append(temp)
                choice = random.choice(temp_contiguous)
                new_maze.remove_wall(choice, temp)
                flag[choice] = True
                pile.append(choice)

        return new_maze

    def gen_wilson(self, h, w) -&gt; object:
        &#34;&#34;&#34;
        Methode d&#39;instance qui génère un labyrinthe à `h` lignes et `w` colonnes parfait à l&#39;aide de l’algorithme de Wilson.

        Paramètres:
            `h` (int) : nombre de cases en hauteur du labyrinthe voulu.
            `w` (int) : nombre de cases en largeur du labyrinthe voulu.

        Retour:
            Retourne une instance de `Maze`.
        &#34;&#34;&#34;

        #Génération d&#39;un labyrinthe plein
        new_maze = Maze(h, w, False)

        #Création de deux listes pour suivre les cellules marquer et non
        no_flag = [(i, j) for i in range(h) for j in range(w)]
        flag = [random.choice(no_flag)]

        # Jusqu&#39;à fin du labyrinthe
        while no_flag:
            #1ʳᵉ celule du chemin
            path = [random.choice(no_flag)]

            # Génération d&#39;un chemin
            new_path = False
            while not new_path:
                cell_voisine = new_maze.get_contiguous_cells(path[len(path) - 1])
                random.shuffle(cell_voisine)

                not_new = 0
                for cell in cell_voisine:
                    if cell in flag:
                        path.append(cell)
                        new_path = True
                        break
                    elif cell in path:
                        not_new += 1
                        continue
                    else:
                        path.append(cell)
                        break

                if not_new == len(cell_voisine):
                    path.clear()
                    break

            # Fin de la création d&#39;un chemin
            if path:
                for i in range(len(path) - 1):
                    new_maze.remove_wall(path[i], path[i + 1])
                    flag.append(no_flag.pop(no_flag.index(path[i])))

                path.clear

        return new_maze


    def overlay(self, content=None):
        &#34;&#34;&#34;
        Rendu en mode texte, sur la sortie standard, \
        d&#39;un labyrinthe avec du contenu dans les cellules
        Argument:
            content (dict) : dictionnaire tq content[cell] contient le caractère à afficher au milieu de la cellule
        Retour:
            string
        &#34;&#34;&#34;
        if content is None:
            content = {(i,j):&#39; &#39; for i in range(self.height) for j in range(self.width)}
        else:
            # Python &gt;=3.9
            #content = content | {(i, j): &#39; &#39; for i in range(
            #    self.height) for j in range(self.width) if (i,j) not in content}
            # Python &lt;3.9
            new_content = {(i, j): &#39; &#39; for i in range(self.height) for j in range(self.width) if (i,j) not in content}
            content = {**content, **new_content}
        txt = r&#34;&#34;
        # Première ligne
        txt += &#34;┏&#34;
        for j in range(self.width-1):
            txt += &#34;━━━┳&#34;
        txt += &#34;━━━┓\n&#34;
        txt += &#34;┃&#34;
        for j in range(self.width-1):
            txt += &#34; &#34;+content[(0,j)]+&#34; ┃&#34; if (0,j+1) not in self.neighbors[(0,j)] else &#34; &#34;+content[(0,j)]+&#34;  &#34;
        txt += &#34; &#34;+content[(0,self.width-1)]+&#34; ┃\n&#34;
        # Lignes normales
        for i in range(self.height-1):
            txt += &#34;┣&#34;
            for j in range(self.width-1):
                txt += &#34;━━━╋&#34; if (i+1,j) not in self.neighbors[(i,j)] else &#34;   ╋&#34;
            txt += &#34;━━━┫\n&#34; if (i+1,self.width-1) not in self.neighbors[(i,self.width-1)] else &#34;   ┫\n&#34;
            txt += &#34;┃&#34;
            for j in range(self.width):
                txt += &#34; &#34;+content[(i+1,j)]+&#34; ┃&#34; if (i+1,j+1) not in self.neighbors[(i+1,j)] else &#34; &#34;+content[(i+1,j)]+&#34;  &#34;
            txt += &#34;\n&#34;
        # Bas du tableau
        txt += &#34;┗&#34;
        for i in range(self.width-1):
            txt += &#34;━━━┻&#34;
        txt += &#34;━━━┛\n&#34;
        return txt

    def solve_dfs(self, start:tuple, stop:tuple):
        &#34;&#34;&#34;
        Méthode d&#39;instance permettant de résoudre le labyrithe en &#34;profondeur&#34;

        Paramètres: 
            `start` (tuple) : cellule de départ du chemin
            `stop` (tuple) : celulle d&#39;arrivée du chemin. 
        Retour: 
            `chemin` (list) : liste des coordonnées correspondant au chemin à parcourir.           
        &#34;&#34;&#34;
        pile=[start]
        pred={}
        marked={}
        chemin=[]
        for i in range(self.height):
            for j in range(self.width):
                marked[(i,j)]=False
        marked[start]=True
        pred[start]=start
        while False in marked.values():
            c=pile.pop(0)
            if c==stop:
                break
            else :
                voisin=self.get_reachable_cells(c)
                for elt in voisin:
                    if marked[elt]==False :
                        marked[elt]=True
                        pile.insert(0,elt)
                        pred[elt]=c
        c=stop
        while c!=start:
            chemin.append(c)
            c=pred[c]
        chemin.append(start)
        return chemin

    def solve_bfs(self, start:tuple, stop:tuple):
        &#34;&#34;&#34;
        Méthode d&#39;instance permettant de résoudre le labyrithe en &#34;profondeur&#34;

        Paramètres: 
            `start` (tuple) : cellule de départ du chemin
            `stop` (tuple) : celulle d&#39;arrivée du chemin. 
        Retour: 
            `chemin` (list) : liste des coordonnées correspondant au chemin à parcourir.           
        &#34;&#34;&#34;
        file=[start]
        pred={}
        marked={}
        chemin=[]
        for i in range(self.height):
            for j in range(self.width):
                marked[(i,j)]=False
        marked[start]=True
        pred[start]=start
        while False in marked.values():
            c=file.pop(len(file)-1)
            if c==stop:
                break
            else :
                voisin=self.get_reachable_cells(c)
                for elt in voisin:
                    if marked[elt]==False :
                        marked[elt]=True
                        file.insert(0,elt)
                        pred[elt]=c
        c=stop
        while c!=start:
            chemin.append(c)
            c=pred[c]
        chemin.append(start)
        return chemin    
    
    &#34;&#34;&#34;
    def solve_Rhr(self, start:tuple, stop:tuple):
        pile=[start]
        pred={}
        marked={}
        chemin=[]
        for i in range(self.height):
            for j in range(self.width):
                marked[(i,j)]=False
        marked[start]=True
        pred[start]=start
        while False in marked.values():
            c=pile.pop(0)
            if c==stop:
                break
            else :
                voisin=self.get_reachable_cells(c)
                delidx=0
                i=0
                while i&lt;len(voisin)-delidx:
                    if marked[voisin[i]]!=False:
                        del voisin[i]
                        delidx+=1
                    i+=1
                print(voisin)
                next_cell=voisin[0]
                for elt in voisin[1:]:
                    if elt[1]&lt;next_cell[1]:
                        next_cell=elt
                marked[next_cell]=True
                pile.insert(0,next_cell)
                pred[next_cell]=c
        c=stop
        while c!=start:
            chemin.append(c)
            c=pred[c]
        chemin.append(start)
        return chemin 
        &#34;&#34;&#34;
    &#34;&#34;&#34;
        directions = [(0, 1), (1, 0), (0, -1), (-1, 0)]
        right_hand_directions = [directions[i - 1] for i in range(len(directions))]
        pile = [start]
        marked = {}
        pred = {}
        chemin = []
        for i in range(self.height):
            for j in range(self.width):
                marked[(i, j)] = False
        marked[start] = True
        pred[start] = start
        current_direction = right_hand_directions[0]
        current_pos = start
        while current_pos != stop:
            print(&#34;boucle&#34;)
            voisin = self.get_reachable_cells(current_pos)
            next_pos = None
            for elt in right_hand_directions:
                if (current_pos[0] + elt[0], current_pos[1] + elt[1]) in voisin:
                    next_pos = (current_pos[0] + elt[0], current_pos[1] + elt[1])
                    current_direction = elt
                    break
            if next_pos is None:
                current_direction = right_hand_directions[(right_hand_directions.index(current_direction) + 1) % len(right_hand_directions)]
                next_pos = (current_pos[0] + current_direction[0], current_pos[1] + current_direction[1])
            if not marked[next_pos]:
                marked[next_pos] = True
                pred[next_pos] = current_pos
                pile.insert(0, next_pos)
            current_pos = next_pos
        c = stop
        while c != start:
            chemin.append(c)
            c = pred[c]
        chemin.append(start)
        chemin.reverse()
        return chemin
        &#34;&#34;&#34;

    &#34;&#34;&#34;
        pile = [start]
        pred = {}
        marked = {}
        chemin = []
        for i in range(self.height):
            for j in range(self.width):
                marked[(i, j)] = False
        marked[start] = True
        pred[start] = start
        direction = &#34;right&#34;  # Commencer en allant à droite
        while pile:
            c = pile[0]
            if c == stop:
                break
            voisins = self.get_reachable_cells(c)
            voisin_droite = None
            for v in voisins:
                if v[0] == c[0]:
                    if v[1] &gt; c[1]:
                        voisin_droite = v
                        break
                elif v[1] == c[1]:
                    if v[0] &gt; c[0]:
                        voisin_droite = v
                        break
            if voisin_droite and not marked[voisin_droite]:
                marked[voisin_droite] = True
                pile.insert(0, voisin_droite)
                pred[voisin_droite] = c
                direction = &#34;right&#34;  # Continuer à aller à droite
            else:
                # Pas de voisin à droite ou voisin déjà visité, essayer la direction suivante
                if direction == &#34;right&#34;:
                    direction = &#34;down&#34;
                    continue
                elif direction == &#34;down&#34;:
                    direction = &#34;left&#34;
                    continue
                elif direction == &#34;left&#34;:
                    direction = &#34;up&#34;
                    continue
                elif direction == &#34;up&#34;:
                    direction = &#34;right&#34;
                    continue
        c = stop
        while c != start:
            chemin.append(c)
            c = pred[c]
        chemin.append(start)
        return chemin
    &#34;&#34;&#34;
    def solve_Rhr(self, start, stop):
        &#34;&#34;&#34;
        Méthode d&#39;instance permettant de résoudre le labyrithe par la main droite.

        Paramètres:
            `start` (tuple) : cellule de départ du chemin
            `stop` (tuple) : celulle d&#39;arrivée du chemin.
        Retour:
            `chemin` (list) : liste des coordonnées correspondant au chemin à parcourir.
        &#34;&#34;&#34;
        chemin=[start]
        direction=4 #1 = bas, 2=gauche, 3= haut, 4=droite
        current=start
        walls=self.get_walls()
        while current!=stop:
            print(chemin)
            if direction==4 and (current, (current[0]+1, current[1])) not in walls:
                direction=1
                current=(current[0]+1, current[1])
                chemin.append(current)
            elif direction==3 and (current,(current[0], current[1]+1)) not in walls:
                direction=4
                current=(current[0], current[1]+1)
                chemin.append(current)  
            elif direction==2 and (current,(current[0]-1, current[1])) not in walls: 
                direction=3
                current=(current[0]-1, current[1])
                chemin.append(current)
            elif direction==1 and (current,(current[0], current[1]-1)) not in walls:
                direction = 2
                current = (current[0], current[1]-1)
                chemin.append(current)
            elif direction==4 and (current, (current[0]+1, current[1])) in walls:
                if (current, (current[0], current[1]+1)):
                    current=(current[0], current[1]+1)
                    chemin.append(current)
                direction=1
            elif direction==3 and (current,(current[0], current[1]+1)) in walls:
                if (current, (current[0]-1, current[1])):
                    current=(current[0]-1, current[1])
                    chemin.append(current)
                direction=4
            elif direction==2 and (current,(current[0]-1, current[1])) in walls:
                if (current, (current[0], current[1]-1)):
                    current=(current[0], current[1]-1)
                    chemin.append(current)
                direction=3
            elif direction==1 and (current,(current[0], current[1]-1)) in walls:
                if (current, (current[0]-1, current[1])):
                    current=(current[0]-1, current[1])
                    chemin.append(current)
                direction=2
        chemin.append(stop)
        return chemin.reverse()




    def distance_geo(self, c1, c2):
        &#34;&#34;&#34;
        Méthode d&#39;instance permettant de trouver la plus courte distance géographique entre deux points à l&#39;aide des algorithmes de résolution.
        Paramètres:
            `start` (tuple) : cellule de départ du chemin
            `stop` (tuple) : celulle d&#39;arrivée du chemin. 
        Retour: 
            `len` (int) : plus courte distance à parcourir.  
        &#34;&#34;&#34;
        resDfs=self.solve_dfs(c1,c2)
        resBfs=self.solve_bfs(c1,c2)
        #resRhr=self.solve_rhr(c1,c2)
        if len(resDfs)&lt;len(resBfs) : # and len(resDfs) &lt; len(resRhr):
            return len(resDfs)
        if len(resBfs)&lt;len(resDfs) : # and len(resBfs) &lt; len(resRhr):
            return len(resBfs)
        # if len(resRhr)&lt;len(resBfs) : # and len(resRhr) &lt; len(resDfs): return len(resRhr)

    def distance_man(self, c1, c2):
        &#34;&#34;&#34;
        Méthode d&#39;instance permettant de trouver la plus courte distance de Manhattan entre deux points à l&#39;aide des algorithmes de résolution.
        Paramètres:
            `start` (tuple) : cellule de départ du chemin
            `stop` (tuple) : celulle d&#39;arrivée du chemin. 
        Retour: 
            `len` (int) : plus courte distance à parcourir.  
        &#34;&#34;&#34;
        return (c2[0]-c1[0])+(c2[1]-c1[1])</code></pre>
</details>
</section>
<section>
</section>
<section>
</section>
<section>
<h2 class="section-title" id="header-functions">Functions</h2>
<dl>
<dt id="Maze.getrandbits"><code class="name flex">
<span>def <span class="ident">getrandbits</span></span>(<span>k, /)</span>
</code></dt>
<dd>
<div class="desc"><p>getrandbits(k) -&gt; x.
Generates an int with k random bits.</p></div>
</dd>
</dl>
</section>
<section>
<h2 class="section-title" id="header-classes">Classes</h2>
<dl>
<dt id="Maze.Maze"><code class="flex name class">
<span>class <span class="ident">Maze</span></span>
<span>(</span><span>height: int, width: int, empty: bool)</span>
</code></dt>
<dd>
<div class="desc"><p>Classe <code><a title="Maze.Maze" href="#Maze.Maze">Maze</a></code> (Labyrinthe) :
Représentation d'un labyrithe sous forme d'un graphe non-orienté
dont chaque sommet est une cellule (sous forme d'un tuple (l,c))
et dont la structure est représentée par un dictionnaire :
clefs = sommets, valeurs = ensemble des sommets voisins accessibles.</p>
<p>Le constructeur de cette classe créer un labyrinthe de <code>height</code> cellules de haut
et de <code>width</code> cellules de large.
Les voisinages sont initialisés par des ensembles vides.
Remarque : dans le labyrinthe créé, chaque cellule est complètement emmurée.</p>
<h2 id="parametres">Paramètres</h2>
<p><code>height</code> (int)</p>
<p><code>width</code> (int)</p>
<p><code>empty</code> (bool).</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class Maze:
    &#34;&#34;&#34;
    Classe `Maze` (Labyrinthe) :
    Représentation d&#39;un labyrithe sous forme d&#39;un graphe non-orienté
    dont chaque sommet est une cellule (sous forme d&#39;un tuple (l,c))
    et dont la structure est représentée par un dictionnaire :
    clefs = sommets, valeurs = ensemble des sommets voisins accessibles.
    &#34;&#34;&#34;

    def __init__(self, height: int, width: int, empty: bool):
        &#34;&#34;&#34;
        Le constructeur de cette classe créer un labyrinthe de `height` cellules de haut
        et de `width` cellules de large.
        Les voisinages sont initialisés par des ensembles vides.
        Remarque : dans le labyrinthe créé, chaque cellule est complètement emmurée.
        Paramètres:
            `height` (int)

            `width` (int)

            `empty` (bool).
        &#34;&#34;&#34;
        self.height = height
        self.width = width

        # Si empty vaut True alors le constructeur initialise l&#39;objet sans murs internes sinon il construit tous les murs

        if empty:
            self.neighbors = {
                (i, j): set() for i in range(height) for j in range(width)
            }
            for h in range(height):
                for w in range(width):
                    if h - 1 &gt;= 0:
                        self.neighbors[(h, w)].add((h - 1, w))
                    if h + 1 &lt;= height - 1:
                        self.neighbors[(h, w)].add((h + 1, w))
                    if w - 1 &gt;= 0:
                        self.neighbors[(h, w)].add((h, w - 1))
                    if w + 1 &lt;= width - 1:
                        self.neighbors[(h, w)].add((h, w + 1))
        else:
            self.neighbors = {
                (i, j): set() for i in range(height) for j in range(width)
            }

    def info(self) -&gt; str:
        &#34;&#34;&#34;
        Affichage des attributs d&#39;un objet `Maze` (fonction utile pour deboguer).
        Retour:
            Chaîne de caractères (str) contenant une description textuelle des attributs de l&#39;intance.
        &#34;&#34;&#34;
        txt = f&#39;{self.height} x {self.width}\n&#39;
        txt += str(self.neighbors)
        return txt

    def __str__(self) -&gt; str:
        &#34;&#34;&#34;
        Représentation textuelle d&#39;une intance de l&#39;objet `Maze` (en utilisant des caractères ASCII).
        Retour:
             Chaîne de caractères (str) : chaîne de caractères représentant le labyrinthe
        :return:
        &#34;&#34;&#34;
        txt = &#39;&#39;
        # Première ligne
        txt += &#39;┏&#39;
        for j in range(self.width - 1):
            txt += &#39;━━━┳&#39;
        txt += &#39;━━━┓\n&#39;
        txt += &#39;┃&#39;
        for j in range(self.width - 1):
            txt += (
                &#39;   ┃&#39; if (0, j + 1) not in self.neighbors[(0, j)] else &#39;    &#39;
            )
        txt += &#39;   ┃\n&#39;
        # Lignes normales
        for i in range(self.height - 1):
            txt += &#39;┣&#39;
            for j in range(self.width - 1):
                txt += (
                    &#39;━━━╋&#39;
                    if (i + 1, j) not in self.neighbors[(i, j)]
                    else &#39;   ╋&#39;
                )
            txt += (
                &#39;━━━┫\n&#39;
                if (i + 1, self.width - 1)
                not in self.neighbors[(i, self.width - 1)]
                else &#39;   ┫\n&#39;
            )
            txt += &#39;┃&#39;
            for j in range(self.width):
                txt += (
                    &#39;   ┃&#39;
                    if (i + 1, j + 1) not in self.neighbors[(i + 1, j)]
                    else &#39;    &#39;
                )
            txt += &#39;\n&#39;
        # Bas du tableau
        txt += &#39;┗&#39;
        for i in range(self.width - 1):
            txt += &#39;━━━┻&#39;
        txt += &#39;━━━┛\n&#39;

        return txt

    def add_wall(self, c1, c2) -&gt; None:
        &#34;&#34;&#34;
        Méthode d&#39;instance permettant d&#39;ajouter un mur entre les deux cases passées en paramètres si et seulement si les coordonnées sont
        cohérentes.

        Paramètres:
            `c1` (tuple) : première coordonnée rerpésentant une case.

            `c2` (tuple) : deuxième coordonnée rerpésentant une autre case.
        &#34;&#34;&#34;
        # On teste si les sommets sont bien dans le labyrinthe
        assert (
            0 &lt;= c1[0] &lt; self.height
            and 0 &lt;= c1[1] &lt; self.width
            and 0 &lt;= c2[0] &lt; self.height
            and 0 &lt;= c2[1] &lt; self.width
        ), (
            &#34;Erreur lors de l&#39;ajout d&#39;un mur entre {c1} et {c2} : les coordonnées de sont pas compatibles avec les &#34;
            &#39;dimensions du labyrinthe&#39;
        )
        # Ajout du mur
        if c2 in self.neighbors[c1]:  # Si c2 est dans les voisines de c1
            self.neighbors[c1].remove(c2)  # on le retire
        if c1 in self.neighbors[c2]:  # Si c3 est dans les voisines de c2
            self.neighbors[c2].remove(c1)  # on le retire

        return None

    def remove_wall(self, c1, c2) -&gt; None:
        &#34;&#34;&#34;
        Méthode d&#39;instance permettant de supprimer un mur entre les deux cases passées en paramètres si et seulement si les coordonnées sont
        cohérentes.
        Paramètres:
            `c1` (tuple) : première coordonnée rerpésentant une case.

            `c2` (tuple) : deuxième coordonnée rerpésentant une autre case.
        &#34;&#34;&#34;
        # On teste si les sommets sont bien dans le labyrinthe
        assert (
            0 &lt;= c1[0] &lt; self.height
            and 0 &lt;= c1[1] &lt; self.width
            and 0 &lt;= c2[0] &lt; self.height
            and 0 &lt;= c2[1] &lt; self.width
        ), (
            &#34;Erreur lors de la suppression d&#39;un mur entre {c1} et {c2} : les coordonnées de sont pas compatibles avec &#34;
            &#39;les dimensions du labyrinthe&#39;
        )
        # Suppression du mur
        if (
            c2 not in self.neighbors[c1]
        ):  # Si c2 n&#39;est pas dans les voisines de c1
            self.neighbors[c1].add(c2)  # on l&#39;ajoute&#39;
        if (
            c1 not in self.neighbors[c2]
        ):  # Si c3 n&#39;est pas dans les voisines de c2
            self.neighbors[c2].add(c1)  # on l&#39;ajoute
        return None

    def get_walls(self) -&gt; list:
        &#34;&#34;&#34;
        Méthode d&#39;instance qui retourne la liste de tous les murs sous la forme d’une liste de tuple de cellules (
        sans redondance ou symétrie).
        &#34;&#34;&#34;
        list_wall = []
        for h in range(self.height):
            for w in range(self.width):

                if (
                    h - 1 &gt;= 0
                    and (h, w) not in self.neighbors[(h - 1, w)]
                    and (
                        ((h, w), (h - 1, w)) not in list_wall
                        and (
                            (h - 1, w),
                            (h, w),
                        )
                        not in list_wall
                    )
                ):
                    list_wall.append(((h, w), (h - 1, w)))

                if (
                    h + 1 &lt;= self.height - 1
                    and (h, w) not in self.neighbors[(h + 1, w)]
                    and (
                        ((h, w), (h + 1, w))
                        and ((h + 1, w), (h, w)) not in list_wall
                    )
                ):
                    list_wall.append(((h, w), (h + 1, w)))

                if (
                    w - 1 &gt;= 0
                    and (h, w) not in self.neighbors[(h, w - 1)]
                    and (
                        ((h, w), (h, w - 1)) not in list_wall
                        and ((h, w - 1), (h, w)) not in list_wall
                    )
                ):
                    list_wall.append(((h, w), (h, w - 1)))

                if (
                    w + 1 &lt;= self.width - 1
                    and (h, w) not in self.neighbors[(h, w + 1)]
                    and (
                        ((h, w), (h, w + 1)) not in list_wall
                        and ((h, w + 1), (h, w)) not in list_wall
                    )
                ):
                    list_wall.append(((h, w), (h, w + 1)))

        return list_wall

    def fill(self) -&gt; None:
        &#34;&#34;&#34;
        Méthode d&#39;instance qui ajoute tous les murs possibles dans un labyrinthe.
        &#34;&#34;&#34;
        for h in range(self.height):
            for w in range(self.width):
                for voisin in self.neighbors[(h, w)].copy():
                    self.add_wall((h, w), voisin)
        return None

    def empty(self) -&gt; None:
        &#34;&#34;&#34;
        Méthode d&#39;instance qui supprime tous les murs d&#39;un labyrinthe.
        &#34;&#34;&#34;
        list_wall = self.get_walls()
        for wall in list_wall:
            self.remove_wall(wall[0], wall[1])
        return None

    def get_contiguous_cells(self, c: tuple) -&gt; list:
        &#34;&#34;&#34;
        Méthode d&#39;instance qui retourne la liste des cellules contigües à une cellule `c` (tuple) passée en paramètre dans la grille (sans s’occuper des
        éventuels murs).

        Paramètre:
            `c` (tuple) : coordonnées d&#39;une cellule.

        Retour:
            Liste de toutes les cellules contigües à `c`.
        &#34;&#34;&#34;
        list_contigue = []
        if c[0] - 1 &gt;= 0:
            list_contigue.append((c[0] - 1, c[1]))
        if c[0] + 1 &lt;= self.height - 1:
            list_contigue.append((c[0] + 1, c[1]))
        if c[1] - 1 &gt;= 0:
            list_contigue.append((c[0], c[1] - 1))
        if c[1] + 1 &lt;= self.width - 1:
            list_contigue.append((c[0], c[1] + 1))

        return list_contigue

    def get_reachable_cells(self, c: tuple) -&gt; list:
        return list(self.neighbors[c].copy())

    def gen_btree(self, h: int, w: int) -&gt; object:
        &#34;&#34;&#34;
        Méthode d&#39;instance qui génère un labyrinthe qui possède `h` lignes et `w`` colonnes en utilisant l’algorithme de
        construction par arbre binaire.

        Paramètres:
            `h` (int) : nombre de cases en hauteur du labyrinthe voulu.
            `w` (int) : nombre de cases en largeur du labyrinthe voulu.

        Retour:
            Retourne une instance de `Maze`.
        &#34;&#34;&#34;
        new_maze = Maze(h, w, False)
        for h in range(new_maze.height):
            for w in range(new_maze.width):

                temp_wall = new_maze.get_walls()
                if (
                    random.choice([True, False])
                    and w + 1 &lt;= new_maze.width - 1
                ):
                    if ((h, w), (h, w + 1)) in temp_wall:
                        new_maze.remove_wall((h, w), (h, w + 1))
                    elif h + 1 &lt;= new_maze.height - 1:
                        new_maze.remove_wall((h, w), (h + 1, w))

                else:
                    if (
                        (h, w),
                        (h + 1, w),
                    ) in temp_wall and h + 1 &lt;= new_maze.height - 1:
                        new_maze.remove_wall((h, w), (h + 1, w))
                    elif w + 1 &lt;= new_maze.width - 1:
                        new_maze.remove_wall((h, w), (h, w + 1))

        return new_maze

    def gen_sidewinder(self, h: int, w: int) -&gt; object:
        &#34;&#34;&#34;
        Méthode d&#39;instance qui génère un labyrinthe de `h` lignes et `w` colonnes en utilisant l’algorithme de construction
        Sidewinder.

        Paramètres:
            `h` (int) : nombre de cases en hauteur du labyrinthe voulu.
            `w` (int) : nombre de cases en largeur du labyrinthe voulu.

        Retour:
            Retourne une instance de `Maze`.
        &#34;&#34;&#34;
        new_maze = Maze(h, w, False)

        for h in range(new_maze.height - 1):
            v_seq = []
            for w in range(new_maze.width - 1):
                v_seq.append((h, w))
                if random.choice([True, False]):
                    new_maze.remove_wall((h, w), (h, w + 1))
                else:
                    choix = random.choice(v_seq)
                    new_maze.remove_wall(choix, (choix[0] + 1, choix[1]))
                    v_seq.clear()
            v_seq.append((h, new_maze.width - 1))
            choix = random.choice(v_seq)
            new_maze.remove_wall(choix, (choix[0] + 1, choix[1]))

        for w in range(new_maze.width - 1):
            new_maze.remove_wall(
                (new_maze.height - 1, w), (new_maze.height - 1, w + 1)
            )
        return new_maze

    def gen_fusion(self, h, w) -&gt; object:
        &#34;&#34;&#34;
        Méthode d&#39;instance qui génère un labyrinthe de `h` lignes et `w` colonnes parfait à l&#39;aide de l’algorithme de fusion de chemins.

        Paramètres:
            `h` (int) : nombre de cases en hauteur du labyrinthe voulu.
            `w` (int) : nombre de cases en largeur du labyrinthe voulu.

        Retour:
            Retourne une instance de `Maze`.
        &#34;&#34;&#34;
        new_maze = Maze(h, w, False)
        label = {(i, j): None for i in range(h) for j in range(w)}
        idx = 1
        for h in range(new_maze.height):
            for w in range(new_maze.width):
                # Ajout des label aux cellules
                label[(h, w)] = idx
                idx += 1
        list_wall = new_maze.get_walls()
        random.shuffle(list_wall)

        for wall in list_wall:
            if label[wall[0]] != label[wall[1]]:
                temp = label[wall[1]]
                for idx in label:
                    if label[idx] == temp:
                        label[idx] = label[wall[0]]
                new_maze.remove_wall(wall[0], wall[1])
        return new_maze

    def gen_exploration(self, h, w) -&gt; object:
        &#34;&#34;&#34;
        Methode d&#39;instance qui génère un labyrinthe à `h` lignes et `w` colonnes parfait à l&#39;aide de l’algorithme d’exploration exhaustive.

        Paramètres:
            `h` (int) : nombre de cases en hauteur du labyrinthe voulu.
            `w` (int) : nombre de cases en largeur du labyrinthe voulu.

        Retour:
            Retourne une instance de `Maze`.
        &#34;&#34;&#34;
        new_maze = Maze(h, w, False)
        flag = {(i, j): False for i in range(h) for j in range(w)}
        pile = []
        temp = (random.randint(0, h - 1), random.randint(0, w - 1))
        pile.append(temp)
        flag[temp] = True
        while pile:
            temp = pile[len(pile) - 1]
            pile.pop(len(pile) - 1)
            temp_test = False
            temp_contiguous = new_maze.get_contiguous_cells(temp)
            for neighbors in temp_contiguous.copy():
                if not flag[neighbors]:
                    temp_test = True
                else:
                    temp_contiguous.remove(neighbors)
            if temp_test:
                pile.append(temp)
                choice = random.choice(temp_contiguous)
                new_maze.remove_wall(choice, temp)
                flag[choice] = True
                pile.append(choice)

        return new_maze

    def gen_wilson(self, h, w) -&gt; object:
        &#34;&#34;&#34;
        Methode d&#39;instance qui génère un labyrinthe à `h` lignes et `w` colonnes parfait à l&#39;aide de l’algorithme de Wilson.

        Paramètres:
            `h` (int) : nombre de cases en hauteur du labyrinthe voulu.
            `w` (int) : nombre de cases en largeur du labyrinthe voulu.

        Retour:
            Retourne une instance de `Maze`.
        &#34;&#34;&#34;

        #Génération d&#39;un labyrinthe plein
        new_maze = Maze(h, w, False)

        #Création de deux listes pour suivre les cellules marquer et non
        no_flag = [(i, j) for i in range(h) for j in range(w)]
        flag = [random.choice(no_flag)]

        # Jusqu&#39;à fin du labyrinthe
        while no_flag:
            #1ʳᵉ celule du chemin
            path = [random.choice(no_flag)]

            # Génération d&#39;un chemin
            new_path = False
            while not new_path:
                cell_voisine = new_maze.get_contiguous_cells(path[len(path) - 1])
                random.shuffle(cell_voisine)

                not_new = 0
                for cell in cell_voisine:
                    if cell in flag:
                        path.append(cell)
                        new_path = True
                        break
                    elif cell in path:
                        not_new += 1
                        continue
                    else:
                        path.append(cell)
                        break

                if not_new == len(cell_voisine):
                    path.clear()
                    break

            # Fin de la création d&#39;un chemin
            if path:
                for i in range(len(path) - 1):
                    new_maze.remove_wall(path[i], path[i + 1])
                    flag.append(no_flag.pop(no_flag.index(path[i])))

                path.clear

        return new_maze


    def overlay(self, content=None):
        &#34;&#34;&#34;
        Rendu en mode texte, sur la sortie standard, \
        d&#39;un labyrinthe avec du contenu dans les cellules
        Argument:
            content (dict) : dictionnaire tq content[cell] contient le caractère à afficher au milieu de la cellule
        Retour:
            string
        &#34;&#34;&#34;
        if content is None:
            content = {(i,j):&#39; &#39; for i in range(self.height) for j in range(self.width)}
        else:
            # Python &gt;=3.9
            #content = content | {(i, j): &#39; &#39; for i in range(
            #    self.height) for j in range(self.width) if (i,j) not in content}
            # Python &lt;3.9
            new_content = {(i, j): &#39; &#39; for i in range(self.height) for j in range(self.width) if (i,j) not in content}
            content = {**content, **new_content}
        txt = r&#34;&#34;
        # Première ligne
        txt += &#34;┏&#34;
        for j in range(self.width-1):
            txt += &#34;━━━┳&#34;
        txt += &#34;━━━┓\n&#34;
        txt += &#34;┃&#34;
        for j in range(self.width-1):
            txt += &#34; &#34;+content[(0,j)]+&#34; ┃&#34; if (0,j+1) not in self.neighbors[(0,j)] else &#34; &#34;+content[(0,j)]+&#34;  &#34;
        txt += &#34; &#34;+content[(0,self.width-1)]+&#34; ┃\n&#34;
        # Lignes normales
        for i in range(self.height-1):
            txt += &#34;┣&#34;
            for j in range(self.width-1):
                txt += &#34;━━━╋&#34; if (i+1,j) not in self.neighbors[(i,j)] else &#34;   ╋&#34;
            txt += &#34;━━━┫\n&#34; if (i+1,self.width-1) not in self.neighbors[(i,self.width-1)] else &#34;   ┫\n&#34;
            txt += &#34;┃&#34;
            for j in range(self.width):
                txt += &#34; &#34;+content[(i+1,j)]+&#34; ┃&#34; if (i+1,j+1) not in self.neighbors[(i+1,j)] else &#34; &#34;+content[(i+1,j)]+&#34;  &#34;
            txt += &#34;\n&#34;
        # Bas du tableau
        txt += &#34;┗&#34;
        for i in range(self.width-1):
            txt += &#34;━━━┻&#34;
        txt += &#34;━━━┛\n&#34;
        return txt

    def solve_dfs(self, start:tuple, stop:tuple):
        &#34;&#34;&#34;
        Méthode d&#39;instance permettant de résoudre le labyrithe en &#34;profondeur&#34;

        Paramètres: 
            `start` (tuple) : cellule de départ du chemin
            `stop` (tuple) : celulle d&#39;arrivée du chemin. 
        Retour: 
            `chemin` (list) : liste des coordonnées correspondant au chemin à parcourir.           
        &#34;&#34;&#34;
        pile=[start]
        pred={}
        marked={}
        chemin=[]
        for i in range(self.height):
            for j in range(self.width):
                marked[(i,j)]=False
        marked[start]=True
        pred[start]=start
        while False in marked.values():
            c=pile.pop(0)
            if c==stop:
                break
            else :
                voisin=self.get_reachable_cells(c)
                for elt in voisin:
                    if marked[elt]==False :
                        marked[elt]=True
                        pile.insert(0,elt)
                        pred[elt]=c
        c=stop
        while c!=start:
            chemin.append(c)
            c=pred[c]
        chemin.append(start)
        return chemin

    def solve_bfs(self, start:tuple, stop:tuple):
        &#34;&#34;&#34;
        Méthode d&#39;instance permettant de résoudre le labyrithe en &#34;profondeur&#34;

        Paramètres: 
            `start` (tuple) : cellule de départ du chemin
            `stop` (tuple) : celulle d&#39;arrivée du chemin. 
        Retour: 
            `chemin` (list) : liste des coordonnées correspondant au chemin à parcourir.           
        &#34;&#34;&#34;
        file=[start]
        pred={}
        marked={}
        chemin=[]
        for i in range(self.height):
            for j in range(self.width):
                marked[(i,j)]=False
        marked[start]=True
        pred[start]=start
        while False in marked.values():
            c=file.pop(len(file)-1)
            if c==stop:
                break
            else :
                voisin=self.get_reachable_cells(c)
                for elt in voisin:
                    if marked[elt]==False :
                        marked[elt]=True
                        file.insert(0,elt)
                        pred[elt]=c
        c=stop
        while c!=start:
            chemin.append(c)
            c=pred[c]
        chemin.append(start)
        return chemin    
    
    &#34;&#34;&#34;
    def solve_Rhr(self, start:tuple, stop:tuple):
        pile=[start]
        pred={}
        marked={}
        chemin=[]
        for i in range(self.height):
            for j in range(self.width):
                marked[(i,j)]=False
        marked[start]=True
        pred[start]=start
        while False in marked.values():
            c=pile.pop(0)
            if c==stop:
                break
            else :
                voisin=self.get_reachable_cells(c)
                delidx=0
                i=0
                while i&lt;len(voisin)-delidx:
                    if marked[voisin[i]]!=False:
                        del voisin[i]
                        delidx+=1
                    i+=1
                print(voisin)
                next_cell=voisin[0]
                for elt in voisin[1:]:
                    if elt[1]&lt;next_cell[1]:
                        next_cell=elt
                marked[next_cell]=True
                pile.insert(0,next_cell)
                pred[next_cell]=c
        c=stop
        while c!=start:
            chemin.append(c)
            c=pred[c]
        chemin.append(start)
        return chemin 
        &#34;&#34;&#34;
    &#34;&#34;&#34;
        directions = [(0, 1), (1, 0), (0, -1), (-1, 0)]
        right_hand_directions = [directions[i - 1] for i in range(len(directions))]
        pile = [start]
        marked = {}
        pred = {}
        chemin = []
        for i in range(self.height):
            for j in range(self.width):
                marked[(i, j)] = False
        marked[start] = True
        pred[start] = start
        current_direction = right_hand_directions[0]
        current_pos = start
        while current_pos != stop:
            print(&#34;boucle&#34;)
            voisin = self.get_reachable_cells(current_pos)
            next_pos = None
            for elt in right_hand_directions:
                if (current_pos[0] + elt[0], current_pos[1] + elt[1]) in voisin:
                    next_pos = (current_pos[0] + elt[0], current_pos[1] + elt[1])
                    current_direction = elt
                    break
            if next_pos is None:
                current_direction = right_hand_directions[(right_hand_directions.index(current_direction) + 1) % len(right_hand_directions)]
                next_pos = (current_pos[0] + current_direction[0], current_pos[1] + current_direction[1])
            if not marked[next_pos]:
                marked[next_pos] = True
                pred[next_pos] = current_pos
                pile.insert(0, next_pos)
            current_pos = next_pos
        c = stop
        while c != start:
            chemin.append(c)
            c = pred[c]
        chemin.append(start)
        chemin.reverse()
        return chemin
        &#34;&#34;&#34;

    &#34;&#34;&#34;
        pile = [start]
        pred = {}
        marked = {}
        chemin = []
        for i in range(self.height):
            for j in range(self.width):
                marked[(i, j)] = False
        marked[start] = True
        pred[start] = start
        direction = &#34;right&#34;  # Commencer en allant à droite
        while pile:
            c = pile[0]
            if c == stop:
                break
            voisins = self.get_reachable_cells(c)
            voisin_droite = None
            for v in voisins:
                if v[0] == c[0]:
                    if v[1] &gt; c[1]:
                        voisin_droite = v
                        break
                elif v[1] == c[1]:
                    if v[0] &gt; c[0]:
                        voisin_droite = v
                        break
            if voisin_droite and not marked[voisin_droite]:
                marked[voisin_droite] = True
                pile.insert(0, voisin_droite)
                pred[voisin_droite] = c
                direction = &#34;right&#34;  # Continuer à aller à droite
            else:
                # Pas de voisin à droite ou voisin déjà visité, essayer la direction suivante
                if direction == &#34;right&#34;:
                    direction = &#34;down&#34;
                    continue
                elif direction == &#34;down&#34;:
                    direction = &#34;left&#34;
                    continue
                elif direction == &#34;left&#34;:
                    direction = &#34;up&#34;
                    continue
                elif direction == &#34;up&#34;:
                    direction = &#34;right&#34;
                    continue
        c = stop
        while c != start:
            chemin.append(c)
            c = pred[c]
        chemin.append(start)
        return chemin
    &#34;&#34;&#34;
    def solve_Rhr(self, start, stop):
        &#34;&#34;&#34;
        Méthode d&#39;instance permettant de résoudre le labyrithe par la main droite.

        Paramètres:
            `start` (tuple) : cellule de départ du chemin
            `stop` (tuple) : celulle d&#39;arrivée du chemin.
        Retour:
            `chemin` (list) : liste des coordonnées correspondant au chemin à parcourir.
        &#34;&#34;&#34;
        chemin=[start]
        direction=4 #1 = bas, 2=gauche, 3= haut, 4=droite
        current=start
        walls=self.get_walls()
        while current!=stop:
            print(chemin)
            if direction==4 and (current, (current[0]+1, current[1])) not in walls:
                direction=1
                current=(current[0]+1, current[1])
                chemin.append(current)
            elif direction==3 and (current,(current[0], current[1]+1)) not in walls:
                direction=4
                current=(current[0], current[1]+1)
                chemin.append(current)  
            elif direction==2 and (current,(current[0]-1, current[1])) not in walls: 
                direction=3
                current=(current[0]-1, current[1])
                chemin.append(current)
            elif direction==1 and (current,(current[0], current[1]-1)) not in walls:
                direction = 2
                current = (current[0], current[1]-1)
                chemin.append(current)
            elif direction==4 and (current, (current[0]+1, current[1])) in walls:
                if (current, (current[0], current[1]+1)):
                    current=(current[0], current[1]+1)
                    chemin.append(current)
                direction=1
            elif direction==3 and (current,(current[0], current[1]+1)) in walls:
                if (current, (current[0]-1, current[1])):
                    current=(current[0]-1, current[1])
                    chemin.append(current)
                direction=4
            elif direction==2 and (current,(current[0]-1, current[1])) in walls:
                if (current, (current[0], current[1]-1)):
                    current=(current[0], current[1]-1)
                    chemin.append(current)
                direction=3
            elif direction==1 and (current,(current[0], current[1]-1)) in walls:
                if (current, (current[0]-1, current[1])):
                    current=(current[0]-1, current[1])
                    chemin.append(current)
                direction=2
        chemin.append(stop)
        return chemin.reverse()




    def distance_geo(self, c1, c2):
        &#34;&#34;&#34;
        Méthode d&#39;instance permettant de trouver la plus courte distance géographique entre deux points à l&#39;aide des algorithmes de résolution.
        Paramètres:
            `start` (tuple) : cellule de départ du chemin
            `stop` (tuple) : celulle d&#39;arrivée du chemin. 
        Retour: 
            `len` (int) : plus courte distance à parcourir.  
        &#34;&#34;&#34;
        resDfs=self.solve_dfs(c1,c2)
        resBfs=self.solve_bfs(c1,c2)
        #resRhr=self.solve_rhr(c1,c2)
        if len(resDfs)&lt;len(resBfs) : # and len(resDfs) &lt; len(resRhr):
            return len(resDfs)
        if len(resBfs)&lt;len(resDfs) : # and len(resBfs) &lt; len(resRhr):
            return len(resBfs)
        # if len(resRhr)&lt;len(resBfs) : # and len(resRhr) &lt; len(resDfs): return len(resRhr)

    def distance_man(self, c1, c2):
        &#34;&#34;&#34;
        Méthode d&#39;instance permettant de trouver la plus courte distance de Manhattan entre deux points à l&#39;aide des algorithmes de résolution.
        Paramètres:
            `start` (tuple) : cellule de départ du chemin
            `stop` (tuple) : celulle d&#39;arrivée du chemin. 
        Retour: 
            `len` (int) : plus courte distance à parcourir.  
        &#34;&#34;&#34;
        return (c2[0]-c1[0])+(c2[1]-c1[1])</code></pre>
</details>
<h3>Methods</h3>
<dl>
<dt id="Maze.Maze.add_wall"><code class="name flex">
<span>def <span class="ident">add_wall</span></span>(<span>self, c1, c2) ‑> None</span>
</code></dt>
<dd>
<div class="desc"><p>Méthode d'instance permettant d'ajouter un mur entre les deux cases passées en paramètres si et seulement si les coordonnées sont
cohérentes.</p>
<h2 id="parametres">Paramètres</h2>
<p><code>c1</code> (tuple) : première coordonnée rerpésentant une case.</p>
<p><code>c2</code> (tuple) : deuxième coordonnée rerpésentant une autre case.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def add_wall(self, c1, c2) -&gt; None:
    &#34;&#34;&#34;
    Méthode d&#39;instance permettant d&#39;ajouter un mur entre les deux cases passées en paramètres si et seulement si les coordonnées sont
    cohérentes.

    Paramètres:
        `c1` (tuple) : première coordonnée rerpésentant une case.

        `c2` (tuple) : deuxième coordonnée rerpésentant une autre case.
    &#34;&#34;&#34;
    # On teste si les sommets sont bien dans le labyrinthe
    assert (
        0 &lt;= c1[0] &lt; self.height
        and 0 &lt;= c1[1] &lt; self.width
        and 0 &lt;= c2[0] &lt; self.height
        and 0 &lt;= c2[1] &lt; self.width
    ), (
        &#34;Erreur lors de l&#39;ajout d&#39;un mur entre {c1} et {c2} : les coordonnées de sont pas compatibles avec les &#34;
        &#39;dimensions du labyrinthe&#39;
    )
    # Ajout du mur
    if c2 in self.neighbors[c1]:  # Si c2 est dans les voisines de c1
        self.neighbors[c1].remove(c2)  # on le retire
    if c1 in self.neighbors[c2]:  # Si c3 est dans les voisines de c2
        self.neighbors[c2].remove(c1)  # on le retire

    return None</code></pre>
</details>
</dd>
<dt id="Maze.Maze.distance_geo"><code class="name flex">
<span>def <span class="ident">distance_geo</span></span>(<span>self, c1, c2)</span>
</code></dt>
<dd>
<div class="desc"><p>Méthode d'instance permettant de trouver la plus courte distance géographique entre deux points à l'aide des algorithmes de résolution.</p>
<h2 id="parametres">Paramètres</h2>
<p><code>start</code> (tuple) : cellule de départ du chemin
<code>stop</code> (tuple) : celulle d'arrivée du chemin.
Retour:
<code>len</code> (int) : plus courte distance à parcourir.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def distance_geo(self, c1, c2):
    &#34;&#34;&#34;
    Méthode d&#39;instance permettant de trouver la plus courte distance géographique entre deux points à l&#39;aide des algorithmes de résolution.
    Paramètres:
        `start` (tuple) : cellule de départ du chemin
        `stop` (tuple) : celulle d&#39;arrivée du chemin. 
    Retour: 
        `len` (int) : plus courte distance à parcourir.  
    &#34;&#34;&#34;
    resDfs=self.solve_dfs(c1,c2)
    resBfs=self.solve_bfs(c1,c2)
    #resRhr=self.solve_rhr(c1,c2)
    if len(resDfs)&lt;len(resBfs) : # and len(resDfs) &lt; len(resRhr):
        return len(resDfs)
    if len(resBfs)&lt;len(resDfs) : # and len(resBfs) &lt; len(resRhr):
        return len(resBfs)
    # if len(resRhr)&lt;len(resBfs) : # and len(resRhr) &lt; len(resDfs): return len(resRhr)</code></pre>
</details>
</dd>
<dt id="Maze.Maze.distance_man"><code class="name flex">
<span>def <span class="ident">distance_man</span></span>(<span>self, c1, c2)</span>
</code></dt>
<dd>
<div class="desc"><p>Méthode d'instance permettant de trouver la plus courte distance de Manhattan entre deux points à l'aide des algorithmes de résolution.</p>
<h2 id="parametres">Paramètres</h2>
<p><code>start</code> (tuple) : cellule de départ du chemin
<code>stop</code> (tuple) : celulle d'arrivée du chemin.
Retour:
<code>len</code> (int) : plus courte distance à parcourir.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def distance_man(self, c1, c2):
    &#34;&#34;&#34;
    Méthode d&#39;instance permettant de trouver la plus courte distance de Manhattan entre deux points à l&#39;aide des algorithmes de résolution.
    Paramètres:
        `start` (tuple) : cellule de départ du chemin
        `stop` (tuple) : celulle d&#39;arrivée du chemin. 
    Retour: 
        `len` (int) : plus courte distance à parcourir.  
    &#34;&#34;&#34;
    return (c2[0]-c1[0])+(c2[1]-c1[1])</code></pre>
</details>
</dd>
<dt id="Maze.Maze.empty"><code class="name flex">
<span>def <span class="ident">empty</span></span>(<span>self) ‑> None</span>
</code></dt>
<dd>
<div class="desc"><p>Méthode d'instance qui supprime tous les murs d'un labyrinthe.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def empty(self) -&gt; None:
    &#34;&#34;&#34;
    Méthode d&#39;instance qui supprime tous les murs d&#39;un labyrinthe.
    &#34;&#34;&#34;
    list_wall = self.get_walls()
    for wall in list_wall:
        self.remove_wall(wall[0], wall[1])
    return None</code></pre>
</details>
</dd>
<dt id="Maze.Maze.fill"><code class="name flex">
<span>def <span class="ident">fill</span></span>(<span>self) ‑> None</span>
</code></dt>
<dd>
<div class="desc"><p>Méthode d'instance qui ajoute tous les murs possibles dans un labyrinthe.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def fill(self) -&gt; None:
    &#34;&#34;&#34;
    Méthode d&#39;instance qui ajoute tous les murs possibles dans un labyrinthe.
    &#34;&#34;&#34;
    for h in range(self.height):
        for w in range(self.width):
            for voisin in self.neighbors[(h, w)].copy():
                self.add_wall((h, w), voisin)
    return None</code></pre>
</details>
</dd>
<dt id="Maze.Maze.gen_btree"><code class="name flex">
<span>def <span class="ident">gen_btree</span></span>(<span>self, h: int, w: int) ‑> object</span>
</code></dt>
<dd>
<div class="desc"><p>Méthode d'instance qui génère un labyrinthe qui possède <code>h</code> lignes et `w`` colonnes en utilisant l’algorithme de
construction par arbre binaire.</p>
<h2 id="parametres">Paramètres</h2>
<p><code>h</code> (int) : nombre de cases en hauteur du labyrinthe voulu.
<code>w</code> (int) : nombre de cases en largeur du labyrinthe voulu.</p>
<h2 id="retour">Retour</h2>
<p>Retourne une instance de <code><a title="Maze.Maze" href="#Maze.Maze">Maze</a></code>.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def gen_btree(self, h: int, w: int) -&gt; object:
    &#34;&#34;&#34;
    Méthode d&#39;instance qui génère un labyrinthe qui possède `h` lignes et `w`` colonnes en utilisant l’algorithme de
    construction par arbre binaire.

    Paramètres:
        `h` (int) : nombre de cases en hauteur du labyrinthe voulu.
        `w` (int) : nombre de cases en largeur du labyrinthe voulu.

    Retour:
        Retourne une instance de `Maze`.
    &#34;&#34;&#34;
    new_maze = Maze(h, w, False)
    for h in range(new_maze.height):
        for w in range(new_maze.width):

            temp_wall = new_maze.get_walls()
            if (
                random.choice([True, False])
                and w + 1 &lt;= new_maze.width - 1
            ):
                if ((h, w), (h, w + 1)) in temp_wall:
                    new_maze.remove_wall((h, w), (h, w + 1))
                elif h + 1 &lt;= new_maze.height - 1:
                    new_maze.remove_wall((h, w), (h + 1, w))

            else:
                if (
                    (h, w),
                    (h + 1, w),
                ) in temp_wall and h + 1 &lt;= new_maze.height - 1:
                    new_maze.remove_wall((h, w), (h + 1, w))
                elif w + 1 &lt;= new_maze.width - 1:
                    new_maze.remove_wall((h, w), (h, w + 1))

    return new_maze</code></pre>
</details>
</dd>
<dt id="Maze.Maze.gen_exploration"><code class="name flex">
<span>def <span class="ident">gen_exploration</span></span>(<span>self, h, w) ‑> object</span>
</code></dt>
<dd>
<div class="desc"><p>Methode d'instance qui génère un labyrinthe à <code>h</code> lignes et <code>w</code> colonnes parfait à l'aide de l’algorithme d’exploration exhaustive.</p>
<h2 id="parametres">Paramètres</h2>
<p><code>h</code> (int) : nombre de cases en hauteur du labyrinthe voulu.
<code>w</code> (int) : nombre de cases en largeur du labyrinthe voulu.</p>
<h2 id="retour">Retour</h2>
<p>Retourne une instance de <code><a title="Maze.Maze" href="#Maze.Maze">Maze</a></code>.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def gen_exploration(self, h, w) -&gt; object:
    &#34;&#34;&#34;
    Methode d&#39;instance qui génère un labyrinthe à `h` lignes et `w` colonnes parfait à l&#39;aide de l’algorithme d’exploration exhaustive.

    Paramètres:
        `h` (int) : nombre de cases en hauteur du labyrinthe voulu.
        `w` (int) : nombre de cases en largeur du labyrinthe voulu.

    Retour:
        Retourne une instance de `Maze`.
    &#34;&#34;&#34;
    new_maze = Maze(h, w, False)
    flag = {(i, j): False for i in range(h) for j in range(w)}
    pile = []
    temp = (random.randint(0, h - 1), random.randint(0, w - 1))
    pile.append(temp)
    flag[temp] = True
    while pile:
        temp = pile[len(pile) - 1]
        pile.pop(len(pile) - 1)
        temp_test = False
        temp_contiguous = new_maze.get_contiguous_cells(temp)
        for neighbors in temp_contiguous.copy():
            if not flag[neighbors]:
                temp_test = True
            else:
                temp_contiguous.remove(neighbors)
        if temp_test:
            pile.append(temp)
            choice = random.choice(temp_contiguous)
            new_maze.remove_wall(choice, temp)
            flag[choice] = True
            pile.append(choice)

    return new_maze</code></pre>
</details>
</dd>
<dt id="Maze.Maze.gen_fusion"><code class="name flex">
<span>def <span class="ident">gen_fusion</span></span>(<span>self, h, w) ‑> object</span>
</code></dt>
<dd>
<div class="desc"><p>Méthode d'instance qui génère un labyrinthe de <code>h</code> lignes et <code>w</code> colonnes parfait à l'aide de l’algorithme de fusion de chemins.</p>
<h2 id="parametres">Paramètres</h2>
<p><code>h</code> (int) : nombre de cases en hauteur du labyrinthe voulu.
<code>w</code> (int) : nombre de cases en largeur du labyrinthe voulu.</p>
<h2 id="retour">Retour</h2>
<p>Retourne une instance de <code><a title="Maze.Maze" href="#Maze.Maze">Maze</a></code>.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def gen_fusion(self, h, w) -&gt; object:
    &#34;&#34;&#34;
    Méthode d&#39;instance qui génère un labyrinthe de `h` lignes et `w` colonnes parfait à l&#39;aide de l’algorithme de fusion de chemins.

    Paramètres:
        `h` (int) : nombre de cases en hauteur du labyrinthe voulu.
        `w` (int) : nombre de cases en largeur du labyrinthe voulu.

    Retour:
        Retourne une instance de `Maze`.
    &#34;&#34;&#34;
    new_maze = Maze(h, w, False)
    label = {(i, j): None for i in range(h) for j in range(w)}
    idx = 1
    for h in range(new_maze.height):
        for w in range(new_maze.width):
            # Ajout des label aux cellules
            label[(h, w)] = idx
            idx += 1
    list_wall = new_maze.get_walls()
    random.shuffle(list_wall)

    for wall in list_wall:
        if label[wall[0]] != label[wall[1]]:
            temp = label[wall[1]]
            for idx in label:
                if label[idx] == temp:
                    label[idx] = label[wall[0]]
            new_maze.remove_wall(wall[0], wall[1])
    return new_maze</code></pre>
</details>
</dd>
<dt id="Maze.Maze.gen_sidewinder"><code class="name flex">
<span>def <span class="ident">gen_sidewinder</span></span>(<span>self, h: int, w: int) ‑> object</span>
</code></dt>
<dd>
<div class="desc"><p>Méthode d'instance qui génère un labyrinthe de <code>h</code> lignes et <code>w</code> colonnes en utilisant l’algorithme de construction
Sidewinder.</p>
<h2 id="parametres">Paramètres</h2>
<p><code>h</code> (int) : nombre de cases en hauteur du labyrinthe voulu.
<code>w</code> (int) : nombre de cases en largeur du labyrinthe voulu.</p>
<h2 id="retour">Retour</h2>
<p>Retourne une instance de <code><a title="Maze.Maze" href="#Maze.Maze">Maze</a></code>.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def gen_sidewinder(self, h: int, w: int) -&gt; object:
    &#34;&#34;&#34;
    Méthode d&#39;instance qui génère un labyrinthe de `h` lignes et `w` colonnes en utilisant l’algorithme de construction
    Sidewinder.

    Paramètres:
        `h` (int) : nombre de cases en hauteur du labyrinthe voulu.
        `w` (int) : nombre de cases en largeur du labyrinthe voulu.

    Retour:
        Retourne une instance de `Maze`.
    &#34;&#34;&#34;
    new_maze = Maze(h, w, False)

    for h in range(new_maze.height - 1):
        v_seq = []
        for w in range(new_maze.width - 1):
            v_seq.append((h, w))
            if random.choice([True, False]):
                new_maze.remove_wall((h, w), (h, w + 1))
            else:
                choix = random.choice(v_seq)
                new_maze.remove_wall(choix, (choix[0] + 1, choix[1]))
                v_seq.clear()
        v_seq.append((h, new_maze.width - 1))
        choix = random.choice(v_seq)
        new_maze.remove_wall(choix, (choix[0] + 1, choix[1]))

    for w in range(new_maze.width - 1):
        new_maze.remove_wall(
            (new_maze.height - 1, w), (new_maze.height - 1, w + 1)
        )
    return new_maze</code></pre>
</details>
</dd>
<dt id="Maze.Maze.gen_wilson"><code class="name flex">
<span>def <span class="ident">gen_wilson</span></span>(<span>self, h, w) ‑> object</span>
</code></dt>
<dd>
<div class="desc"><p>Methode d'instance qui génère un labyrinthe à <code>h</code> lignes et <code>w</code> colonnes parfait à l'aide de l’algorithme de Wilson.</p>
<h2 id="parametres">Paramètres</h2>
<p><code>h</code> (int) : nombre de cases en hauteur du labyrinthe voulu.
<code>w</code> (int) : nombre de cases en largeur du labyrinthe voulu.</p>
<h2 id="retour">Retour</h2>
<p>Retourne une instance de <code><a title="Maze.Maze" href="#Maze.Maze">Maze</a></code>.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def gen_wilson(self, h, w) -&gt; object:
    &#34;&#34;&#34;
    Methode d&#39;instance qui génère un labyrinthe à `h` lignes et `w` colonnes parfait à l&#39;aide de l’algorithme de Wilson.

    Paramètres:
        `h` (int) : nombre de cases en hauteur du labyrinthe voulu.
        `w` (int) : nombre de cases en largeur du labyrinthe voulu.

    Retour:
        Retourne une instance de `Maze`.
    &#34;&#34;&#34;

    #Génération d&#39;un labyrinthe plein
    new_maze = Maze(h, w, False)

    #Création de deux listes pour suivre les cellules marquer et non
    no_flag = [(i, j) for i in range(h) for j in range(w)]
    flag = [random.choice(no_flag)]

    # Jusqu&#39;à fin du labyrinthe
    while no_flag:
        #1ʳᵉ celule du chemin
        path = [random.choice(no_flag)]

        # Génération d&#39;un chemin
        new_path = False
        while not new_path:
            cell_voisine = new_maze.get_contiguous_cells(path[len(path) - 1])
            random.shuffle(cell_voisine)

            not_new = 0
            for cell in cell_voisine:
                if cell in flag:
                    path.append(cell)
                    new_path = True
                    break
                elif cell in path:
                    not_new += 1
                    continue
                else:
                    path.append(cell)
                    break

            if not_new == len(cell_voisine):
                path.clear()
                break

        # Fin de la création d&#39;un chemin
        if path:
            for i in range(len(path) - 1):
                new_maze.remove_wall(path[i], path[i + 1])
                flag.append(no_flag.pop(no_flag.index(path[i])))

            path.clear

    return new_maze</code></pre>
</details>
</dd>
<dt id="Maze.Maze.get_contiguous_cells"><code class="name flex">
<span>def <span class="ident">get_contiguous_cells</span></span>(<span>self, c: tuple) ‑> list</span>
</code></dt>
<dd>
<div class="desc"><p>Méthode d'instance qui retourne la liste des cellules contigües à une cellule <code>c</code> (tuple) passée en paramètre dans la grille (sans s’occuper des
éventuels murs).</p>
<h2 id="parametre">Paramètre</h2>
<p><code>c</code> (tuple) : coordonnées d'une cellule.</p>
<h2 id="retour">Retour</h2>
<p>Liste de toutes les cellules contigües à <code>c</code>.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def get_contiguous_cells(self, c: tuple) -&gt; list:
    &#34;&#34;&#34;
    Méthode d&#39;instance qui retourne la liste des cellules contigües à une cellule `c` (tuple) passée en paramètre dans la grille (sans s’occuper des
    éventuels murs).

    Paramètre:
        `c` (tuple) : coordonnées d&#39;une cellule.

    Retour:
        Liste de toutes les cellules contigües à `c`.
    &#34;&#34;&#34;
    list_contigue = []
    if c[0] - 1 &gt;= 0:
        list_contigue.append((c[0] - 1, c[1]))
    if c[0] + 1 &lt;= self.height - 1:
        list_contigue.append((c[0] + 1, c[1]))
    if c[1] - 1 &gt;= 0:
        list_contigue.append((c[0], c[1] - 1))
    if c[1] + 1 &lt;= self.width - 1:
        list_contigue.append((c[0], c[1] + 1))

    return list_contigue</code></pre>
</details>
</dd>
<dt id="Maze.Maze.get_reachable_cells"><code class="name flex">
<span>def <span class="ident">get_reachable_cells</span></span>(<span>self, c: tuple) ‑> list</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def get_reachable_cells(self, c: tuple) -&gt; list:
    return list(self.neighbors[c].copy())</code></pre>
</details>
</dd>
<dt id="Maze.Maze.get_walls"><code class="name flex">
<span>def <span class="ident">get_walls</span></span>(<span>self) ‑> list</span>
</code></dt>
<dd>
<div class="desc"><p>Méthode d'instance qui retourne la liste de tous les murs sous la forme d’une liste de tuple de cellules (
sans redondance ou symétrie).</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def get_walls(self) -&gt; list:
    &#34;&#34;&#34;
    Méthode d&#39;instance qui retourne la liste de tous les murs sous la forme d’une liste de tuple de cellules (
    sans redondance ou symétrie).
    &#34;&#34;&#34;
    list_wall = []
    for h in range(self.height):
        for w in range(self.width):

            if (
                h - 1 &gt;= 0
                and (h, w) not in self.neighbors[(h - 1, w)]
                and (
                    ((h, w), (h - 1, w)) not in list_wall
                    and (
                        (h - 1, w),
                        (h, w),
                    )
                    not in list_wall
                )
            ):
                list_wall.append(((h, w), (h - 1, w)))

            if (
                h + 1 &lt;= self.height - 1
                and (h, w) not in self.neighbors[(h + 1, w)]
                and (
                    ((h, w), (h + 1, w))
                    and ((h + 1, w), (h, w)) not in list_wall
                )
            ):
                list_wall.append(((h, w), (h + 1, w)))

            if (
                w - 1 &gt;= 0
                and (h, w) not in self.neighbors[(h, w - 1)]
                and (
                    ((h, w), (h, w - 1)) not in list_wall
                    and ((h, w - 1), (h, w)) not in list_wall
                )
            ):
                list_wall.append(((h, w), (h, w - 1)))

            if (
                w + 1 &lt;= self.width - 1
                and (h, w) not in self.neighbors[(h, w + 1)]
                and (
                    ((h, w), (h, w + 1)) not in list_wall
                    and ((h, w + 1), (h, w)) not in list_wall
                )
            ):
                list_wall.append(((h, w), (h, w + 1)))

    return list_wall</code></pre>
</details>
</dd>
<dt id="Maze.Maze.info"><code class="name flex">
<span>def <span class="ident">info</span></span>(<span>self) ‑> str</span>
</code></dt>
<dd>
<div class="desc"><p>Affichage des attributs d'un objet <code><a title="Maze.Maze" href="#Maze.Maze">Maze</a></code> (fonction utile pour deboguer).</p>
<h2 id="retour">Retour</h2>
<p>Chaîne de caractères (str) contenant une description textuelle des attributs de l'intance.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def info(self) -&gt; str:
    &#34;&#34;&#34;
    Affichage des attributs d&#39;un objet `Maze` (fonction utile pour deboguer).
    Retour:
        Chaîne de caractères (str) contenant une description textuelle des attributs de l&#39;intance.
    &#34;&#34;&#34;
    txt = f&#39;{self.height} x {self.width}\n&#39;
    txt += str(self.neighbors)
    return txt</code></pre>
</details>
</dd>
<dt id="Maze.Maze.overlay"><code class="name flex">
<span>def <span class="ident">overlay</span></span>(<span>self, content=None)</span>
</code></dt>
<dd>
<div class="desc"><p>Rendu en mode texte, sur la sortie standard,
d'un labyrinthe avec du contenu dans les cellules</p>
<h2 id="argument">Argument</h2>
<p>content (dict) : dictionnaire tq content[cell] contient le caractère à afficher au milieu de la cellule</p>
<h2 id="retour">Retour</h2>
<p>string</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def overlay(self, content=None):
    &#34;&#34;&#34;
    Rendu en mode texte, sur la sortie standard, \
    d&#39;un labyrinthe avec du contenu dans les cellules
    Argument:
        content (dict) : dictionnaire tq content[cell] contient le caractère à afficher au milieu de la cellule
    Retour:
        string
    &#34;&#34;&#34;
    if content is None:
        content = {(i,j):&#39; &#39; for i in range(self.height) for j in range(self.width)}
    else:
        # Python &gt;=3.9
        #content = content | {(i, j): &#39; &#39; for i in range(
        #    self.height) for j in range(self.width) if (i,j) not in content}
        # Python &lt;3.9
        new_content = {(i, j): &#39; &#39; for i in range(self.height) for j in range(self.width) if (i,j) not in content}
        content = {**content, **new_content}
    txt = r&#34;&#34;
    # Première ligne
    txt += &#34;┏&#34;
    for j in range(self.width-1):
        txt += &#34;━━━┳&#34;
    txt += &#34;━━━┓\n&#34;
    txt += &#34;┃&#34;
    for j in range(self.width-1):
        txt += &#34; &#34;+content[(0,j)]+&#34; ┃&#34; if (0,j+1) not in self.neighbors[(0,j)] else &#34; &#34;+content[(0,j)]+&#34;  &#34;
    txt += &#34; &#34;+content[(0,self.width-1)]+&#34; ┃\n&#34;
    # Lignes normales
    for i in range(self.height-1):
        txt += &#34;┣&#34;
        for j in range(self.width-1):
            txt += &#34;━━━╋&#34; if (i+1,j) not in self.neighbors[(i,j)] else &#34;   ╋&#34;
        txt += &#34;━━━┫\n&#34; if (i+1,self.width-1) not in self.neighbors[(i,self.width-1)] else &#34;   ┫\n&#34;
        txt += &#34;┃&#34;
        for j in range(self.width):
            txt += &#34; &#34;+content[(i+1,j)]+&#34; ┃&#34; if (i+1,j+1) not in self.neighbors[(i+1,j)] else &#34; &#34;+content[(i+1,j)]+&#34;  &#34;
        txt += &#34;\n&#34;
    # Bas du tableau
    txt += &#34;┗&#34;
    for i in range(self.width-1):
        txt += &#34;━━━┻&#34;
    txt += &#34;━━━┛\n&#34;
    return txt</code></pre>
</details>
</dd>
<dt id="Maze.Maze.remove_wall"><code class="name flex">
<span>def <span class="ident">remove_wall</span></span>(<span>self, c1, c2) ‑> None</span>
</code></dt>
<dd>
<div class="desc"><p>Méthode d'instance permettant de supprimer un mur entre les deux cases passées en paramètres si et seulement si les coordonnées sont
cohérentes.</p>
<h2 id="parametres">Paramètres</h2>
<p><code>c1</code> (tuple) : première coordonnée rerpésentant une case.</p>
<p><code>c2</code> (tuple) : deuxième coordonnée rerpésentant une autre case.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def remove_wall(self, c1, c2) -&gt; None:
    &#34;&#34;&#34;
    Méthode d&#39;instance permettant de supprimer un mur entre les deux cases passées en paramètres si et seulement si les coordonnées sont
    cohérentes.
    Paramètres:
        `c1` (tuple) : première coordonnée rerpésentant une case.

        `c2` (tuple) : deuxième coordonnée rerpésentant une autre case.
    &#34;&#34;&#34;
    # On teste si les sommets sont bien dans le labyrinthe
    assert (
        0 &lt;= c1[0] &lt; self.height
        and 0 &lt;= c1[1] &lt; self.width
        and 0 &lt;= c2[0] &lt; self.height
        and 0 &lt;= c2[1] &lt; self.width
    ), (
        &#34;Erreur lors de la suppression d&#39;un mur entre {c1} et {c2} : les coordonnées de sont pas compatibles avec &#34;
        &#39;les dimensions du labyrinthe&#39;
    )
    # Suppression du mur
    if (
        c2 not in self.neighbors[c1]
    ):  # Si c2 n&#39;est pas dans les voisines de c1
        self.neighbors[c1].add(c2)  # on l&#39;ajoute&#39;
    if (
        c1 not in self.neighbors[c2]
    ):  # Si c3 n&#39;est pas dans les voisines de c2
        self.neighbors[c2].add(c1)  # on l&#39;ajoute
    return None</code></pre>
</details>
</dd>
<dt id="Maze.Maze.solve_Rhr"><code class="name flex">
<span>def <span class="ident">solve_Rhr</span></span>(<span>self, start, stop)</span>
</code></dt>
<dd>
<div class="desc"><p>Méthode d'instance permettant de résoudre le labyrithe par la main droite.</p>
<h2 id="parametres">Paramètres</h2>
<p><code>start</code> (tuple) : cellule de départ du chemin
<code>stop</code> (tuple) : celulle d'arrivée du chemin.</p>
<h2 id="retour">Retour</h2>
<p><code>chemin</code> (list) : liste des coordonnées correspondant au chemin à parcourir.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def solve_Rhr(self, start, stop):
    &#34;&#34;&#34;
    Méthode d&#39;instance permettant de résoudre le labyrithe par la main droite.

    Paramètres:
        `start` (tuple) : cellule de départ du chemin
        `stop` (tuple) : celulle d&#39;arrivée du chemin.
    Retour:
        `chemin` (list) : liste des coordonnées correspondant au chemin à parcourir.
    &#34;&#34;&#34;
    chemin=[start]
    direction=4 #1 = bas, 2=gauche, 3= haut, 4=droite
    current=start
    walls=self.get_walls()
    while current!=stop:
        print(chemin)
        if direction==4 and (current, (current[0]+1, current[1])) not in walls:
            direction=1
            current=(current[0]+1, current[1])
            chemin.append(current)
        elif direction==3 and (current,(current[0], current[1]+1)) not in walls:
            direction=4
            current=(current[0], current[1]+1)
            chemin.append(current)  
        elif direction==2 and (current,(current[0]-1, current[1])) not in walls: 
            direction=3
            current=(current[0]-1, current[1])
            chemin.append(current)
        elif direction==1 and (current,(current[0], current[1]-1)) not in walls:
            direction = 2
            current = (current[0], current[1]-1)
            chemin.append(current)
        elif direction==4 and (current, (current[0]+1, current[1])) in walls:
            if (current, (current[0], current[1]+1)):
                current=(current[0], current[1]+1)
                chemin.append(current)
            direction=1
        elif direction==3 and (current,(current[0], current[1]+1)) in walls:
            if (current, (current[0]-1, current[1])):
                current=(current[0]-1, current[1])
                chemin.append(current)
            direction=4
        elif direction==2 and (current,(current[0]-1, current[1])) in walls:
            if (current, (current[0], current[1]-1)):
                current=(current[0], current[1]-1)
                chemin.append(current)
            direction=3
        elif direction==1 and (current,(current[0], current[1]-1)) in walls:
            if (current, (current[0]-1, current[1])):
                current=(current[0]-1, current[1])
                chemin.append(current)
            direction=2
    chemin.append(stop)
    return chemin.reverse()</code></pre>
</details>
</dd>
<dt id="Maze.Maze.solve_bfs"><code class="name flex">
<span>def <span class="ident">solve_bfs</span></span>(<span>self, start: tuple, stop: tuple)</span>
</code></dt>
<dd>
<div class="desc"><p>Méthode d'instance permettant de résoudre le labyrithe en "profondeur"</p>
<p>Paramètres:
<code>start</code> (tuple) : cellule de départ du chemin
<code>stop</code> (tuple) : celulle d'arrivée du chemin.
Retour:
<code>chemin</code> (list) : liste des coordonnées correspondant au chemin à parcourir.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def solve_bfs(self, start:tuple, stop:tuple):
    &#34;&#34;&#34;
    Méthode d&#39;instance permettant de résoudre le labyrithe en &#34;profondeur&#34;

    Paramètres: 
        `start` (tuple) : cellule de départ du chemin
        `stop` (tuple) : celulle d&#39;arrivée du chemin. 
    Retour: 
        `chemin` (list) : liste des coordonnées correspondant au chemin à parcourir.           
    &#34;&#34;&#34;
    file=[start]
    pred={}
    marked={}
    chemin=[]
    for i in range(self.height):
        for j in range(self.width):
            marked[(i,j)]=False
    marked[start]=True
    pred[start]=start
    while False in marked.values():
        c=file.pop(len(file)-1)
        if c==stop:
            break
        else :
            voisin=self.get_reachable_cells(c)
            for elt in voisin:
                if marked[elt]==False :
                    marked[elt]=True
                    file.insert(0,elt)
                    pred[elt]=c
    c=stop
    while c!=start:
        chemin.append(c)
        c=pred[c]
    chemin.append(start)
    return chemin    </code></pre>
</details>
</dd>
<dt id="Maze.Maze.solve_dfs"><code class="name flex">
<span>def <span class="ident">solve_dfs</span></span>(<span>self, start: tuple, stop: tuple)</span>
</code></dt>
<dd>
<div class="desc"><p>Méthode d'instance permettant de résoudre le labyrithe en "profondeur"</p>
<p>Paramètres:
<code>start</code> (tuple) : cellule de départ du chemin
<code>stop</code> (tuple) : celulle d'arrivée du chemin.
Retour:
<code>chemin</code> (list) : liste des coordonnées correspondant au chemin à parcourir.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def solve_dfs(self, start:tuple, stop:tuple):
    &#34;&#34;&#34;
    Méthode d&#39;instance permettant de résoudre le labyrithe en &#34;profondeur&#34;

    Paramètres: 
        `start` (tuple) : cellule de départ du chemin
        `stop` (tuple) : celulle d&#39;arrivée du chemin. 
    Retour: 
        `chemin` (list) : liste des coordonnées correspondant au chemin à parcourir.           
    &#34;&#34;&#34;
    pile=[start]
    pred={}
    marked={}
    chemin=[]
    for i in range(self.height):
        for j in range(self.width):
            marked[(i,j)]=False
    marked[start]=True
    pred[start]=start
    while False in marked.values():
        c=pile.pop(0)
        if c==stop:
            break
        else :
            voisin=self.get_reachable_cells(c)
            for elt in voisin:
                if marked[elt]==False :
                    marked[elt]=True
                    pile.insert(0,elt)
                    pred[elt]=c
    c=stop
    while c!=start:
        chemin.append(c)
        c=pred[c]
    chemin.append(start)
    return chemin</code></pre>
</details>
</dd>
</dl>
</dd>
</dl>
</section>
</article>
<nav id="sidebar">
<h1>Index</h1>
<div class="toc">
<ul></ul>
</div>
<ul id="index">
<li><h3><a href="#header-functions">Functions</a></h3>
<ul class="">
<li><code><a title="Maze.getrandbits" href="#Maze.getrandbits">getrandbits</a></code></li>
</ul>
</li>
<li><h3><a href="#header-classes">Classes</a></h3>
<ul>
<li>
<h4><code><a title="Maze.Maze" href="#Maze.Maze">Maze</a></code></h4>
<ul class="">
<li><code><a title="Maze.Maze.add_wall" href="#Maze.Maze.add_wall">add_wall</a></code></li>
<li><code><a title="Maze.Maze.distance_geo" href="#Maze.Maze.distance_geo">distance_geo</a></code></li>
<li><code><a title="Maze.Maze.distance_man" href="#Maze.Maze.distance_man">distance_man</a></code></li>
<li><code><a title="Maze.Maze.empty" href="#Maze.Maze.empty">empty</a></code></li>
<li><code><a title="Maze.Maze.fill" href="#Maze.Maze.fill">fill</a></code></li>
<li><code><a title="Maze.Maze.gen_btree" href="#Maze.Maze.gen_btree">gen_btree</a></code></li>
<li><code><a title="Maze.Maze.gen_exploration" href="#Maze.Maze.gen_exploration">gen_exploration</a></code></li>
<li><code><a title="Maze.Maze.gen_fusion" href="#Maze.Maze.gen_fusion">gen_fusion</a></code></li>
<li><code><a title="Maze.Maze.gen_sidewinder" href="#Maze.Maze.gen_sidewinder">gen_sidewinder</a></code></li>
<li><code><a title="Maze.Maze.gen_wilson" href="#Maze.Maze.gen_wilson">gen_wilson</a></code></li>
<li><code><a title="Maze.Maze.get_contiguous_cells" href="#Maze.Maze.get_contiguous_cells">get_contiguous_cells</a></code></li>
<li><code><a title="Maze.Maze.get_reachable_cells" href="#Maze.Maze.get_reachable_cells">get_reachable_cells</a></code></li>
<li><code><a title="Maze.Maze.get_walls" href="#Maze.Maze.get_walls">get_walls</a></code></li>
<li><code><a title="Maze.Maze.info" href="#Maze.Maze.info">info</a></code></li>
<li><code><a title="Maze.Maze.overlay" href="#Maze.Maze.overlay">overlay</a></code></li>
<li><code><a title="Maze.Maze.remove_wall" href="#Maze.Maze.remove_wall">remove_wall</a></code></li>
<li><code><a title="Maze.Maze.solve_Rhr" href="#Maze.Maze.solve_Rhr">solve_Rhr</a></code></li>
<li><code><a title="Maze.Maze.solve_bfs" href="#Maze.Maze.solve_bfs">solve_bfs</a></code></li>
<li><code><a title="Maze.Maze.solve_dfs" href="#Maze.Maze.solve_dfs">solve_dfs</a></code></li>
</ul>
</li>
</ul>
</li>
</ul>
</nav>
</main>
<footer id="footer">
<p>Generated by <a href="https://pdoc3.github.io/pdoc" title="pdoc: Python API documentation generator"><cite>pdoc</cite> 0.10.0</a>.</p>
</footer>
</body>
</html>